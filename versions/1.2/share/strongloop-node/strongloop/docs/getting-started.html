<h1>Getting Started with StrongLoop Node</h1>

<p>In this Getting Started guide we are going to start with installing StrongLoop Node then configure and run a sample application -- a blog engine -- to demonstrate how one can build an application using StrongLoop Node.</p>

<h1>The What of StrongLoop Node</h1>

<p>StrongLoop Node is a packaged distribution of Node.js, NPM and a set of StrongLoop utilities (not available in the beta release). All of these are installed in global locations, meaning you can use the "node" and "npm" commands from your terminal once you install StrongLoop Node.</p>

<h1>The How of StrongLoop Node</h1>

<p>As a packaged distribution of Node.js and NPM, at its core you can consider using StrongLoop Node as you would use Node.js. Therefore, how StrongLoop Node works is effectively identical except that the packages have been tested, certified, and you can get support from StrongLoop if you're using StrongLoop Node.</p>

<p>In this guide we'll get you going with StrongLoop Node and explore a sample blogging application.</p>

<h1>Installing StrongLoop Node</h1>

<p>First, <a href="http://www.strongloop.com/products#downloads">download</a> the StrongLoop Node distribution for your platform.</p>

<p><em>For Windows or MacOS X, the installer will guide you through the installation.</em></p>

<p><em>NOTE: On MacOS Mountain Lion, you'll need to right-click or command-click the .pkg file and choose Open or else you'll get a security warning. On Windows, please accept the "Unknown" publisher. The packages will be signed when the 1.0.0 release is out.</em></p>

<p><strong>Debian</strong></p>

<p>For Debian packages, use the following command:</p>

<pre><code>$ sudo dpkg -i &lt;deb file name&gt;
</code></pre>

<p><strong>RPM</strong></p>

<p>For RPM packages, use the following command:</p>

<pre><code>$ sudo rpm -i &lt;rpm file name&gt;
</code></pre>

<p>Once you finish the installation, the <code>node</code> command will be available on the <code>PATH</code>.</p>

<ul>
<li><strong>Linux (Deb &amp; RPM)</strong> - /usr/bin</li>
<li><strong>MacOS</strong> - /usr/local/bin</li>
<li><strong>Windows (x64)</strong> - C:\Program Files\StrongLoop Node</li>
<li><strong>Windows (x86)</strong> - C:\Program Files (x86)\StrongLoop Node</li>
</ul>

<h2>Get the sample blog application</h2>

<p>The sample blog application is installed by default at the following locations varied by the platforms.</p>

<ul>
<li><strong>Linux (Deb &amp; RPM)</strong> - /usr/share/strongloop-node/samples/sample-blog</li>
<li><strong>MacOS</strong> - /usr/local/share/strongloop-node/samples/sampleblog</li>
<li><strong>Windows (x64)</strong> - C:\Program Files\StrongLoop Node\strongloop-sampleapps\sample-blog</li>
<li><strong>Windows (x86)</strong> - C:\Program Files (x86)\StrongLoop</li>
</ul>

<p>If you are a git user, you can also clone it from the StrongLoop github repository:</p>

<pre><code>$ git clone git://github.com/strongloop/sample-blog.git
</code></pre>

<h2>Run the sample blog application</h2>

<p>The sample blog application uses MongoDB to store blog entries and users. Before you run it, you'll have to install or configure MongoDB.</p>

<p>To install MongoDB, you can follow instructions <a href="http://www.mongodb.org/downloads">here</a>. Version <strong>2.2.3</strong> is recommended.</p>

<p>If you've just installed mongodb you can run it by going to the directory where you installed it and running:</p>

<pre><code>$ mkdir sample-blog-db
$ bin/mongod --dbpath sample-blog-db
</code></pre>

<p>This creates a data directory called sample-blog-db and tells mongo to start and use that directory. If you already have a mongodb you want to use somewhere, you can edit the connection variables in sample-blog/config/config.js. Now you can start the sample-blog application as follows:</p>

<pre><code>$ cd sample-blog
$ npm install (only required if you check out the source code from github)
$ node app
</code></pre>

<p>You should see messages on the console:</p>

<pre><code>Sample blog server listening on port 3000
MongoDB connection opened
</code></pre>

<p>Now try the following links inside your web browser:</p>

<ul>
<li>View all posts -- http://localhost:3000</li>
<li>View all posts as JSON -- http://localhost:3000/rest/blogs</li>
<li>View all users as JSON -- http://localhost:3000/rest/users</li>
<li>Create a new post (username: strongloop, pw: password) -- http://localhost:3000/post</li>
</ul>

<p><img src="http://strongloop.com/images/strongloop_blog.png" alt="Blog" title="" /></p>

<p>Now that we know the application works as intended, let's look at the blog's structure to get an idea of how we arrived at the endpoint.</p>

<h1>Understand the architecture</h1>

<p>The blog uses a model-view-controller setup. The following diagram illustrates the building blocks that consist of the application built with StrongLoop Node.</p>

<p><img src="http://strongloop.com/images/architecture_map.jpg" alt="Architecture" title="" /></p>

<h1>Walk through the application flow</h1>

<p>Let's walk through what's behind the scenes so that you can better understand how all of the pieces work together. The first one is when you the hit <a href="http://localhost:3000">http://localhost:3000</a> URL.</p>

<ol>
<li>The browser sends an HTTP GET / request to the StrongLoop Node server.</li>
<li>The Express route for / kicks in, and it invokes the 'index' function as the controller.</li>
<li>The controller calls Mongoose blog model to retrieve all blog entries from MongoDB.</li>
<li>The EJS template for home page is rendered with the data from step 3.</li>
<li>The HTML response is sent back to the browser.</li>
</ol>

<p>The second flow is more involved. When you hit the 'New Post' button, it will bring up the Blog posting page so that you can create a new blog. Again, there are multiple steps involved within the application.</p>

<ol>
<li>The browser sends an HTTP GET /post request to the StrongLoop Node server.</li>
<li>The Express authentication handler backed by Passport intercepts the request, as the /post URL is protected.</li>
<li>Since the user hasn't logged in yet, a redirect to the Login page is sent back to the browser.</li>
<li>The browser sends an HTTP GET /login request to StrongLoop Node server.</li>
<li>The Express route for /login kicks in, and it invokes the 'loginForm' function as the controller.</li>
<li>The controller renders the login form from its EJS template. The HTML response is sent back to the browser.</li>
<li>The user types in the user name/password and click on the 'Login'.</li>
<li>The Express route for POST /login calls the passport module which in turn invokes the Mongoose User model to make sure it has a record matching the user name/password. If yes, it redirects the browser back to the blog post page.</li>
<li>Now the user fills in the title/content and click on the 'Save' button.</li>
<li>The browser sends an HTTP POST /post request to StrongLoop Node server.</li>
<li>The Express authentication handler intercepts the request again and it finds out the user is authenticated. It let the request continue to flow to the Express route for POST /post.</li>
<li>The route calls Mongoose blog model to save the newly created blog into MongoDB and send a redirect to / back to the browser.</li>
<li>Now the browser gets the <a href="http://localhost:3000">http://localhost:3000</a> page as we described in the first flow. Your new post will show up at the top of the page.</li>
</ol>

<h2>Build the sample-blog</h2>

<p>When you reach this section, we assume that you now have a good understanding of the sample blog application written in Node.js. Are you interested in building your own? Let's go step by step to illustrate how we build the sample-blog application using StrongLoop Node.</p>

<h3>1. Create a skeleton web application</h3>

<pre><code>$ slnode create web sample-blog -mr

  create : sample-blog/app.js
  create : sample-blog/package.json
  create : sample-blog/public/stylesheets/style.css
  create : sample-blog/routes/index.js
  create : sample-blog/views/index.ejs
  create : sample-blog/db/config.js
  create : sample-blog/db/mongo-store.js
  create : sample-blog/models/user.js
  create : sample-blog/sample-blog
  create : sample-blog/routes/resource.js

$ cd sample-blog
$ slnode install
</code></pre>

<p>This will create a simple Express based web application. There are several important files to explain:</p>

<p><code>package.json</code> - is the node.js package descriptor. It defines the name, version and dependencies of the application.</p>

<p><code>app.js</code> - is a JavaScript file serving as the main program for sample blog application. It creates a web server and registers Express routes and views.</p>

<h3>2. Define data models using Mongoose schema</h3>

<p>For the blog application, we need a persistent store to keep user data and blog entries. We choose MongoDB (http://www.mongodb.org) and the Mongoose (http://mongoosejs.com) module for node as the persistence layer.</p>

<p>To start, we need to define the blog and user schemas using Mongoose so that we can create, retrieve, update, and delete the corresponding entities easily. For example, user will have properties such as username, password, first name, last name, and email. Blog will have properties such as author, title, content, and comments. See http://mongoosejs.com/docs/guide.html for more information.</p>

<p>There are two models needed for the blog application:</p>

<ul>
<li>models/blog.js</li>
<li>models/user.js</li>
</ul>

<!-- break -->

<pre><code>var mongoose = require('mongoose');
var Schema = mongoose.Schema;
var CommentSchema = new Schema({
    author:{type:String, index: true},
    body:{type:String},
    date:{type:Date, default: new Date()}
});
var BlogSchema = new Schema({
    title:{type:String, index: true},
    body:{type:String},
    author:{type:String, index: true},
    date:{type:Date, default: new Date()},
    tags:{type:[String], index: true},
    comments: [CommentSchema]
});
</code></pre>

<h3>3. Configure and connect to MongoDB</h3>

<p>We have covered how to install a new MongoDB database or reuse and existing one in previous sections. To make it easy to make changes, we abstract the MongoDB related configuration into an object inside config/config.js. The relevant snippet is:</p>

<pre><code>exports.creds = {
  mongo: {
    'hostname': 'localhost',
    'port': 27017,
    'username': '',
    'password': '',
    'db': 'sample-blog_development'
  }
}
</code></pre>

<p>There is also code that reads the configuration and create connection to the given MongoDB database. The file is db/mongo-store.js.</p>

<h3>4. Expose data services as REST APIs</h3>

<p>Now we have the blog model defined. Can we access the blog entries remotely using REST APIs? Yes! With Mongoose and Express, it's actually pretty straightforward.</p>

<p>We use HTTP POST /rest/blogs to create a new blog entry. First, we add new function create as follows:</p>

<pre><code>/**
 * Create a new entity */
exports.create = function(mongoose) {
  var mongo = mongoose;
  return function(req, res, next) {
      var mongoModel = mongo.model(req.params.resource);
      if(!mongoModel) {
          next();
          return;
      }
      mongoModel.create(req.body, function (err, obj) {
          if (err) {
              console.log(err);
              res.send(500, err);
          }
          else {
              res.send(200, obj);
          }
      });
  };
}
</code></pre>

<p>Interestingly, the create function can be used to create instances against any defined Mongoose models as it uses the resource name to look up the schema. The body of the HTTP request is the JSON representation of the entity.</p>

<p>Now we need to tell Express that the create function will be used to handle HTTP POST to /rest/:resource URLs. The registration is just one line of code:</p>

<pre><code>// Create a new entity
app.post('/rest/:resource', exports.create(mongoose));
</code></pre>

<p>The corresponding file for our sample application is /routes/resource.js. You can find all CRUD operations are supported:</p>

<table class="standard_table">
  <tbody>
    <tr>
      <td><strong>HTTP Verb</strong></td>
      <td><strong>URL Pattern</strong></td>
      <td><strong>MongoDB Operation</strong></td>
    </tr>
    <tr>
      <td>POST</td>
      <td>/rest/:resource</td>
      <td>Create a new document</td>
    </tr>
    <tr>
      <td>GET</td>
      <td>/rest/:resource?skip=&amp;limit=</td>
      <td>List all documents for the given collection. Optionally, skip and limit
      parameters can be provides from the query string to support pagination</td>
    </tr>
    <tr>
      <td>GET</td>
      <td>/rest/:resource/:id</td>
      <td>Retrieve a document by id</td>
    </tr>
    <tr>
      <td>PUT</td>
      <td>/rest/:resource/:id</td>
      <td>Update a document by id</td>
    </tr>
    <tr>
      <td>DELETE</td>
      <td>/rest/:resource/:id</td>
      <td>Delete a document by id</td>
    </tr>
  </tbody>
</table>

<h3>5. Enable authentication</h3>

<p>On the Internet, certain web pages or APIs need to be protected so that only authorized users can access them. For example, we will secure the REST APIs as well as the blog post page so that only logged in users can create blog posts.</p>

<p>Luckily, with Express and Passport (http://passportjs.org) modules, the job is not difficult. There are a few simple steps to enable authentication.</p>

<h4>1. Define a passport strategy so that it knows which authentication mechanism to use. In our case, we use the user collection from the MongoDB. It's defined in routes/auth.js.</h4>

<pre><code>passport.use(new LocalStrategy(function(username, password, done) {
  User.findByUsernamePassword(username, password, function(err, user) {
      if (err) {
          return done(err);
      }
      if (!user) {
          return done(null, false);
      }
      return done(null, user);
  });
}));
</code></pre>

<h4>2. We also need to have a few forms/pages to deal with login, logout, and account information. These are modeled as Express views and routes too. See views/account.ejs and views/login.ejs.</h4>

<h4>3. Glue all the pieces together</h4>

<pre><code>/**
 * Set up the login handler
 */
exports.setup = function(app) {
  app.use(passport.initialize());
  app.use(passport.session());
  app.all('/post', function(req, res, next) {
      console.log(req.path);
      if (req.path === "/login") {
          next();
      } else {
          ensure.ensureLoggedIn('/login')(req, res, next);
      }
  });
  app.get('/login', exports.loginForm);
  app.post('/login', exports.login);
  app.get('/logout', exports.logout);
  app.get('/account', exports.account);
};
</code></pre>

<h4>6. Add test cases</h4>

<p>Developing an application cannot go well without test cases. There are various test frameworks for Node.js. We use mocha (http://visionmedia.github.com/mocha) for the sample application. Typically, you can add test cases to /test folder and name them as <code>*- mocha.js</code>.</p>

<p>In package.json, create a script so that you can use "npm test" to run the test cases.</p>

<pre><code>"scripts": {
  "start": "node app",
  "test": "./node_modules/mocha/bin/mocha --timeout 30000 --reporter spec test/*-mocha.js --noAuth"
}
</code></pre>

<h4>7. Add client-side artifacts</h4>

<p>At this point, we pretty much have all the backend code ready for the blog application. If you are comfortable with REST APIs, you can definitely start to use 'curl' scripts to try out the blog functions. It would be nice to have simple UI to list blog entries, add comments, and create new entries.</p>

<p>Here is the list of artifacts we add to provide the UI.</p>

<p>views/index.ejs: The EJS template for index page that lists all blog entries. It take an array of blog entries.
views/post.ejs: The form to post new blog entries.
There are peers of these two views in Express routes:</p>

<p>routes/index.js: Define the functions to list blog entries and update them with new comments.
routes/post.js: Define the functions to render post form and create new blog entries.
The routes also register URLs, such as:</p>

<pre><code>exports.setup = function(app) {
  app.get('/', exports.index);
  app.post('/postComment', exports.postComment);
};
exports.setup = function(app) {
  app.get('/post', exports.post);
  app.post('/post', exports.save);
};
</code></pre>

<p>The last piece of the puzzle is static assets, such as HTML files, images, or CSS sheets. We place them under /public and register a static handler with Express in app.js as follows:</p>

<pre><code>app.use(express.static(path.join(__dirname, 'public')));
</code></pre>

<h4>8. Run the demo</h4>

<p><strong>Finally, it's demo time!</strong></p>

<pre><code>$ cd sample-blog
$ mkdir sample-blog-db
$ mongod --dbpath=sample-blog-db
$ slnode install
$ node app
</code></pre>

<p>Enjoy the blog application at: <a href="http://localhost:3000/">http://localhost:3000/</a></p>

<h2>Monitoring your applications with StrongOps</h2>

<p>StrongOps provides real-time monitoring for your Node.js application.  We allow
you to gain detailed, real-time performance monitoring of your Node.js
application services so you can see everything that is happening, as it happens.
This includes understanding system usage at every moment in time to uncover and
resolve issues within the application as they arise.</p>

<p>Adding StrongOps support is easy, visit <a href="http://nodefly.com">nodefly</a> and
register. Once you've registered, visit the <a href="http://nodefly.com/#howto">howto
page</a>, and copy the API key out of section "2. Code",
its a long hexadecimal string.</p>

<p>Insert the following code at the very top of app.js (it must be the first code
run by your app):</p>

<pre><code>require('strong-agent').profile(
  'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',
  ['com.strongloop.example.blog']
);
</code></pre>

<p>where the series of 'xx...xx' will be your key.</p>

<p>As a last step, you need to install the strong-agent module, and you will be
ready to run the app:</p>

<pre><code>$ slnode install --save strong-agent
$ node app
</code></pre>

<p>That's all it takes! Now go back to the nodefly home page, and wait for the
dashboard to appear with live real-time performance data (the dashboard won't be
visible until the app starts to report performance data).</p>

<p>For more information about StrongOps and nodefly, see [[FIXME]].</p>

<h2>Clustering the sample blog application</h2>

<p>Clustering the application means using Node's built-in support for running as a
cluster of identical workers,
all listening on the same port. It's possible to use the
<a href="http://nodejs.org/docs/latest/api/cluster.html">cluster</a>
module directly, but in keeping with the node core design philosophy of
providing fundamental mechanism, the cluster module has very basic functionality. 
Instead, we will use the strong-cluster-control module to both start a cluster,
and also allow run-time management of the cluster from the command line.</p>

<p>Once you start the cluster controller in your app, it automatically maintains a
set number of workers, and listens on a control port so you can reconfigure your
cluster at run-time.</p>

<p>Functionality of the <code>clusterctl</code> utility is straight-forward:</p>

<ul>
<li>status: worker cluster IDs and process IDs</li>
<li>set-size: set the number or workers you want in your cluster</li>
<li>disconnect: disconnect all the workers, causing the controller to start new
ones</li>
<li>fork: fork another worker</li>
</ul>

<p>If you think your node instance are under-utilized, and it makes sense to have
less workers, you can set the size lower without taking your application down.
Or if your node instances are running as hard as they can, and you still have
free CPU you can increase the number of workers.</p>

<p>The cluster-controller might also help you do live upgrades of your workers. If
you have updated the source, and want to restart all your workers, disconnect
them. As they exit, the controller will fork new ones to replace them, which
will be running the new code.</p>

<p>So, lets get started. We are going to add two small blocks of code to the
sample-blog's app.js, that's all it takes. At the very top, after the</p>

<pre><code>, setup = require('./app-setup.js');
</code></pre>

<p>Add the following code:</p>

<pre><code>if(cluster.isMaster) {
  control.start({
    size: control.CPUS
  });
} else {
</code></pre>

<p>and at the very end of the file, as the very last line, add a single <code>}</code>:</p>

<pre><code>}
</code></pre>

<p>to match the <code>else {</code> you added above.</p>

<p>As a last step, you need to install the strong-cluster-control module, and you
will be ready to run the app:</p>

<pre><code>$ slnode install --save strong-cluster-control
$ node app
</code></pre>

<p>The app.js will now run as the cluster master, maintaining the cluster size. We
chose a cluster size according to the number of CPUs you have. This is a good
default, but you should do performance tuning to confirm that this is the right
choice for your application under load.</p>

<p>If you decide that it is not the right choice, you don't have to restart your
app. Lets look at the other aspect of strong-cluster-control, the <code>clusterctl</code>
command line interface. In the sample-app directory, run:</p>

<pre><code>$ ./node_modules/.bin/clusterctl 
worker count: 2
worker id 0: { pid: 7696 }
worker id 1: { pid: 7703 }
</code></pre>

<p>Note that we are running the CLI from your locally installed node modules. It
will always be there, but if you would like to install it globally, you can do
this in the standard node way:</p>

<pre><code>$ slnode install -g strong-cluster-control
</code></pre>

<p>Which should install the <code>clusterctl</code> utility into your path.</p>

<p>Now, perhaps you decide you want 4 workers, instead of 2, to get better
utilization of your system, try this:</p>

<pre><code>$ ./node_modules/.bin/clusterctl set-size 4
$ ./node_modules/.bin/clusterctl status
worker count: 4
worker id 0: { pid: 7696 }
worker id 1: { pid: 7703 }
worker id 2: { pid: 7705 }
worker id 3: { pid: 7707 }
</code></pre>

<p>For more information on the strong-cluster-control modules, see the
[[FIXME strong-cluster-control blog]],
or check out the API and CLI documentation on
<a href="http://github.com/strongloop/strong-cluster-control">github</a>.</p>

<h2>Interacting with StrongLoop Node over the command line (slnode)</h2>

<p><code>slnode</code> is a command line tool that ships with StrongLoop Node for building and managing applications. It's a Swiss-Army knife tool that provides commands for scaffolding, testing and running Node.js source code.</p>

<p><strong><code>slnode</code> offers a list of subcommands:</strong></p>

<ul>
<li><strong>create</strong>: initialize a new StrongLoop Node project, and create boilerplate for modules and packages</li>
<li><strong>run</strong>: run a specified script</li>
<li><strong>npm</strong>: run a specified npm command</li>
<li><strong>env</strong>: print node environment information</li>
<li><strong>install</strong>: install a package from the StrongLoop Node npm repository and/or community repository</li>
<li><strong>test</strong>: run tests</li>
<li><strong>version</strong>: print the version of StrongLoop Node</li>
</ul>

<h2>Creating applications</h2>

<p>The <code>create</code> command supports a few program types. The web type is used by default and when generated includes the following:</p>

<ul>
<li><strong>package.json</strong> - dependencies and other package configuration</li>
<li><strong>app.js</strong> - app entry point and runtime configuration</li>
<li><strong>public</strong> - for holding static assets (images, css, et al)</li>
<li><strong>routes</strong> - route handler functions</li>
<li><strong>views</strong> - templates for rendering html</li>
</ul>

<p>You can create a simple web application with just a single command:</p>

<pre><code>$ slnode create web my-app
</code></pre>

<p>Run the newly created app with the following commands.</p>

<pre><code>$ cd my-app
$ slnode run app.js
</code></pre>

<h2>Creating boilerplate for modules</h2>

<p>The create command also makes it easy to create boilerplate code for a new module you can then publish to npm or simply <code>require</code> in your application. You can do this by executing:</p>

<pre><code>$ slnode create module my-module
</code></pre>

<p>This command also supports automatically generating tests:</p>

<pre><code>$ slnode create module my-module --test
</code></pre>

<p>and allows you to supply a stream type to implement:</p>

<pre><code>$ slnode create module my-module --stream transform
</code></pre>

<p>For more information see the help for each command:</p>

<pre><code>$ slnode create -h
$ slnode create module -h
</code></pre>

<h2>Running node scripts</h2>

<p>You can run node scripts with slnode:</p>

<pre><code>$ slnode [run] [script] [script-args]
</code></pre>

<p>For example,</p>

<pre><code>$ slnode app.js
$ slnode run app
$ slnode app.js -a info
</code></pre>

<h2>Running npm commands</h2>

<p>For your convenience, slnode also supports npm commands as follows:</p>

<pre><code>$ slnode [npm] &lt;npm-command&gt; [npm-command-args]
</code></pre>

<p>Please note that npm is optional if the npm-command name doesn't conflict with other slnode commands or scripts.</p>

<p>For example,</p>

<pre><code>$ slnode install -f
$ slnode ls
$ slnode npm rm express
</code></pre>

<p>The commonly used commands are:</p>

<ul>
<li><strong><a href="https://npmjs.org/doc/install.html">install</a></strong> Install a package</li>
<li><strong><a href="https://npmjs.org/doc/link.html">link</a></strong> Symlink a package folder</li>
<li><strong><a href="https://npmjs.org/doc/list.html">ls/list</a></strong> List installed packages</li>
<li><strong><a href="https://npmjs.org/doc/outdated.html">outdated</a></strong> Check for outdated packages</li>
<li><strong><a href="https://npmjs.org/doc/prune.html">prune</a></strong> Remove extraneous packages</li>
<li><strong><a href="https://npmjs.org/doc/rebuild.html">rebuild</a></strong> Rebuild a package</li>
<li><strong><a href="https://npmjs.org/doc/dedupe.html">dedupe</a></strong> Reduce duplication</li>
<li><strong><a href="https://npmjs.org/doc/rm.html">rm/uninstall</a></strong> Remove a package</li>
<li><strong><a href="https://npmjs.org/doc/update.html">update</a></strong> Update a package</li>
<li><strong><a href="https://npmjs.org/doc/shrinkwrap.html">shrinkwrap</a></strong> Lock down dependency versions</li>
<li><strong><a href="https://npmjs.org/doc/run-script.html">run-script</a></strong> Run arbitrary package scripts</li>
<li><strong><a href="https://npmjs.org/doc/start.html">start</a></strong> Start a package</li>
<li><strong><a href="https://npmjs.org/doc/stop.html">stop</a></strong> Stop a package</li>
<li><strong><a href="https://npmjs.org/doc/restart.html">restart</a></strong> Start a package</li>
<li><strong><a href="https://npmjs.org/doc/test.html">test</a></strong> Test a package </li>
</ul>

<h1>Debugging node applications</h1>

<p>In this guide we are going to debug the sample blog application that comes as
a part of StrongLoop Node distribution. See
<a href="http://strongloop.com/products/resources#?t=building-a-blog-engine">Building a blog engine</a>
for instructions on setting up the application.</p>

<h2>Running the debugger</h2>

<p>The blog application is started by the following command:</p>

<pre><code>$ node app.js
</code></pre>

<p>You can run the application in a debugger as follows:</p>

<pre><code>$ slnode debug app.js
</code></pre>

<p>The command will do three steps under the hood:</p>

<ol>
<li>Start the application in debug mode.</li>
<li>Start node-inspector - a debugger with HTML-based GUI.</li>
<li>Open node-inspector page in your default browser.</li>
</ol>

<p>Here is a screenshot of a node-inspector page in Chrome:</p>

<p><img src="node-inspector-initial.png" width="745px" alt="Initial screenshot"></img></p>

<p><strong>NOTE:</strong> node-inspector works only in Chrome browser at the moment. If you
are using a different browser, you will have to reopen node-inspector page
in Chrome.</p>

<h2>Working with node-inspector</h2>

<p>Now it's the time to set a breakpoint and inspect what's going on under the
hood of our blog application.</p>

<p>Click on the "Show navigator" icon in the upper-left corner to see a tree-list
of all blog source files. Expand "routes" folder and double-click on
"index.js". Click on line number 29 to set a breakpoint at the
beginning of <code>postComment</code> function.</p>

<p>You should get a screen like this:</p>

<p><img src="node-inspector-breakpoint.png" width="745px" alt="Screenshot of a source file with breakpoint set"></img></p>

<p>Open the blog application in a new tab and submit a comment. You can see that
the page is waiting for the server to respond. This is because
the server process is paused on our breakpoint.</p>

<p>Switch to node-inspector's tab in the browser to inspect the fields of the
incomming http request. Leave your mouse over a variable or a property
to see it's value.</p>

<p><img src="node-inspector-value-popup.png" width="745px" alt="Screenshot of a property value displayed in a popup"></img></p>

<p>You can step through javascript statements by pressing F10. Use F8 to resume
script execution after you are done.</p>

<p>Check out <a href="https://developers.google.com/chrome-developer-tools/docs/javascript-debugging">Chrome Developer Tools Guide</a>
for a walkthrough of other debugger features. (Remember that node-inspector
is based on Chrome Developer Tools and most features work exactly the same.)</p>

<h1>Private NPM registry</h1>

<p>Any team building private source, non-trivial Node.js applications soon
realizes the need for a private NPM registry. Here is short guide on how to
configure one yourself.</p>

<h2>Setup the server</h2>

<p>The first step is to setup a Reggie instance which will act as your npm
registry.</p>

<ol>
<li><p>Prepare a server machine for the registry. The machine should be accessible
by all team members and has node.js installed.</p></li>
<li><p>Install Reggie as a global application</p>

<pre><code>$ npm install -g reggie
</code></pre></li>
<li><p>Create a directory where Reggie will store all packages and other run-time
data.</p>

<pre><code>$ mkdir ~/reggie-data
</code></pre></li>
<li><p>Start the Reggie server (at the default port 8080)</p>

<pre><code>$ reggie-server -d ~/reggie-data
</code></pre>

<p>You might want to extend your <code>init.d</code> scripts so that the Reggie server
is automatically started after reboots.</p>

<p>Check <a href="https://github.com/mbrevoort/node-reggie/blob/master/README.md#start-up-options">Reggie's manual</a>
on how to change the default port and other settings.</p></li>
</ol>

<h2>Publishing packages</h2>

<p>First install the reggie CLI client on your development machine:</p>

<pre><code>$ npm install -g reggie
</code></pre>

<p>Then you can publish a package to your private registry using the <code>publish</code>
command:</p>

<pre><code>$ reggie -u http://{reggie-host}:8080/ publish
</code></pre>

<h2>Specifying package dependencies</h2>

<p>The npm client does not support multiple registries (yet), but fortunatelly
it can download packages from any URL.</p>

<p>Use the following command to install a 1.0.0 version of a private package named
'private-helpers':</p>

<pre><code>$ npm install --save http://{reggie-host}:8080/package/private-helpers/1.0.0
</code></pre>

<p>This will also add a dependency entry into your <code>package.json</code> file:</p>

<pre><code>dependencies: {
  "private-helpers": "http://{reggie-host}:8080/package/private-helpers/1.0.0"
}
</code></pre>

<p>Reggie supports version wildcards too, consult
<a href="https://github.com/mbrevoort/node-reggie/blob/master/README.md#resolving-packages-from-reggie">the manual</a>
for description of wildcard version URLs.</p>

<h1>Amazon EC2</h1>

<p>StrongLoop provides Amazon Machine Images (AMIs) with pre-installed StrongLoop
Node distribution to simplify the deployment of node applications to
AWS EC2.</p>

<h2>Booting up a new AWS EC2 instance</h2>

<ol>
<li><p>Log into your Amazon AWS account at <a href="http://aws.amazon.com/">http://aws.amazon.com/</a></p></li>
<li><p>Go to My Account/Console &gt; AWS Management Console &gt; EC2.</p></li>
<li><p>Choose to "Launch Instance" from EC2 Dashboard &gt; INSTANCES &gt;
Instances.</p></li>
<li><p>Create a new instance using the Classic Wizard.</p>

<p><img src="ami-classic-wizard.png" alt="Classic Wizard" title="" /></p></li>
<li><p>Choose "Community AMIs" and search for AMI ID: <code>ami-3ba9390b</code> (SLNode 1.0.2)</p>

<p><img src="ami-search-community.png" alt="Search Community AMIs" title="" /></p></li>
<li><p>Create a key pair for secure connections or choose an existing one.</p></li>
<li><p>A new instance will be created and listed under EC2 Dashboard &gt;
INSTANCES &gt; Instances</p>

<p><img src="ami-instances.png" alt="AMI Instances" title="" /></p></li>
</ol>

<h2>Connecting to the instance</h2>

<p>You can use <code>ssh</code> to log into the AWS instance.  The host name can be
found in instance details (see the second arrow in the screenshot above).</p>

<p>Example:</p>

<pre><code>$ ssh ec2-user@ec2-54-213-17-194.us-west-2.compute.amazonaws.com
</code></pre>

<p><img src="ami-ssh.png" alt="SSH to the instance" title="" /></p>
